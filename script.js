// ### Tasks/Activities:

// #### Activity 1: Variable Declaration
// 1. Declare a variable using var, assign it a number, and log the value to the console.
// 2. Declare a variable using let, assign it a string, and log the value to the console.

// #### Activity 2: Constant Declaration
// 3. Declare a variable using const, assign it a boolean value, and log the value to the console.

// #### Activity 3: Data Types
// 4. Create variables of different data types (number, string, boolean, object, array) and log each variable's type using the typeof operator.

// #### Activity 4: Reassigning Variables
// 5. Declare a variable using let, assign it an initial value, reassign a new value, and log both values to the console.

// #### Activity 5: Understanding const
// 6. Try reassigning a variable declared with const and observe the error.

// var a=5
// console.log(a)

// let str="Hello"
// console.log(str)

// const b=true;
// console.log(b)

// let c=4
// let d="hello"
// let e=true
// let f={1:2}
// let g=["siddhant"]
// console.log(typeof(c))
// console.log(typeof(d))
// console.log(typeof(e))
// console.log(typeof(f))
// console.log(typeof(g))


// let n1=5
// console.log(n1)
//  n1=6
// console.log(n1)

// const n2=75
// console.log(n2)
// n2=74
// console.log(n2)



























// Activity 1: Arithmetic Operations

// Task 1: Write a program to add two numbers and log the result to the console.
// let a=5
// let b=6
// let c=a+b
// console.log(c)
 


// // Task 2: Write a program to subtract two numbers and log the result to the console. Task 3: Write a program to multiply two numbers and log the result to the console.
// let d=5
// let e=6
// let f=d*e
// console.log(f)
// // Task 4: Write a program to divide two numbers and log the result to the console.
//     let g=5
//     let h=6
//     let i=g/h
//     console.log(i)

// // • Task 5: Write a program to find the remainder when one number is divided by another and log the result to the console.
// let j=5
// let k=6
// let l=j%k
// console.log(l)

// // Activity 2: Assignment Operators

// // Task 6: Use the + operator to add a number to a variable and log the result to the console.

// let m=5
// let n=6
// let o=m+n
// console.log(o)

// // • Task 7: Use the operator to subtract a number from a variable and log the result to the console.

// let p=5
// let q=6
// let r=p-q
// console.log(r)
// // Activity 3: Comparison Operators

// // Task 8: Write a program to compare two numbers using > and < and log the result to the console.
// let s=5
// let t=6
// let u=s<t
// console.log(u)


// // Task 9: Write a program to compare two numbers using >= and <= and log the result to the console.

// let v=5     
// let w=6
// let x=v<=w
// console.log(x)

// // Task 10: Write a program to compare two numbers using == and === and log the result to the console.

// let y=5
// let z=6
// let a1=y==z
// console.log(a1)

// let b1=5
// let c1=6
// let d1=b1===c1
// console.log(d1)


// // Activity 4: Logical Operators

// // Task 11: Write a program that uses the && operator to combine two conditions and log the result to the console. 
// let e1=5
// let f1=6
// if (e1==5 && f1==6){
//     console.log(true)
// }


// // Task 12: Write a program that uses the || operator to combine two conditions and log the result to the console.

// let g1=5
// let h1=34
// if (g1==5 || h1==6){
//     console.log(true)
// }

// // • Task 13: Write a program that uses the operator to negate a condition and log the result to the console.
//   a3=true
//   ~a3
//   console.log(a3)


// // Activity 5: Ternary Operator

// // • Task 14: Write a program that uses the ternary operator to check if a number is positive or negative and log the result to the console.

// let i1 = 5;
// (i1 % 2 ==0) ? console.log("Even") : console.log("Odd")


















// // Activity 1: If-Else Statements

// // Task 1: Write a program to check if a number is positive, negative, or zero, and log the result to the console.
// let a = 3;
// if (a > 0) {
//     console.log("Positive");
// } else if (a < 0) {
//     console.log("Negative");
// } else {
//     console.log("Zero");
// }

// // Task 2: Write a program to check if a person is eligible to vote (age >= 18) and log the result to the console.
// let b = 20;
// if (b >= 18) {
//     console.log("Eligible");
// } else {
//     console.log("Not Eligible");
// }

// // Activity 2: Nested If-Else Statements

// // Task 3: Write a program to find the largest of three numbers using nested if-else statements.
// let c = 5;
// let d = 6;
// let e = 7;
// if (c > d) {
//     if (c > e) {
//         console.log(c);
//     } else {
//         console.log(e);
//     }
// } else {
//     if (d > e) {
//         console.log(d);
//     } else {
//         console.log(e);
//     }
// }

// // Activity 3: Switch Case

// // Task 4: Write a program that uses a switch case to determine the day of the week based on a number (1-7) and log the day name to the console.
// let f = 5;
// switch (f) {
//     case 1:
//         console.log("Monday");
//         break;
//     case 2:
//         console.log("Tuesday");
//         break;
//     case 3:
//         console.log("Wednesday");
//         break;
//     case 4:
//         console.log("Thursday");
//         break;
//     case 5:
//         console.log("Friday");
//         break;
//     case 6:
//         console.log("Saturday");
//         break;
//     case 7:
//         console.log("Sunday");
//         break;
//     default:
//         console.log("Invalid day number");
// }

// // Task 5: Write a program that uses a switch case to assign a grade ('A', 'B', 'C', 'D', 'F) based on a score and log the grade to the console.
// let g = 5;
// switch (g) {
//     case 1:
//         console.log("A");
//         break;
//     case 2:
//         console.log("B");
//         break;
//     case 3:
//         console.log("C");
//         break;
//     case 4:
//         console.log("D");
//         break;
//     case 5:
//         console.log("F");
//         break;
//     default:
//         console.log("Invalid score");
// }

// // Activity 4: Conditional (Ternary) Operator

// // Task 6: Write a program that uses the ternary operator to check if a number is even or odd and log the result to the console.
// let h = 5;
// (h % 2 == 0) ? console.log("Even") : console.log("Odd");

// // Activity 5: Combining Conditions

// // Task 7: Write a program to check if a year is a leap year using multiple conditions (divisible by 4, but not 100 unless also divisible by 400) and log the result to the console.
// let i = 2024;
// if ((i % 4 == 0 && i % 100 != 0) || i % 400 == 0) {
//     console.log("Leap Year");
// } else {
//     console.log("Not Leap Year");
// }














// // 1. for Loops:

// // Print numbers from 1 to 10:
// // 
// for (let i = 1; i <= 10; i++) {
//   console.log(i);
// }


// // Print the multiplication table of 5:

// for (let i = 1; i <= 10; i++) {
//   console.log(5 * i);
// }


// // 2. while Loops:

// // Calculate the sum of numbers from 1 to 10:

// let sum = 0;
// let i = 1;
// while (i <= 10) {
//   sum += i;
//   i++;
// }
// console.log("Sum:", sum);


// // Print numbers from 10 to 1:

// let q = 10;
// while (i >= 1) {
//   console.log(i);
//   i--;
// }


// // 3. do-while Loops:

// // Print numbers from 1 to 5:

// let h = 1;
// do {
//   console.log(i);
//   i++;
// } while (i <= 5);


// // Calculate the factorial of a number (assuming the number is provided as an input):

// function factorial(number) {
//   let result = 1;
//   let i = 1;
//   do {
//     result *= i;
//     i++;
//   } while (i <= number);
//   return result;
// }


// const num = 5;
// const fact = factorial(num);
// console.log("Factorial of", num, ":", fact);


// // 4. Nested Loops (Printing the pattern):


// for (let i = 1; i <= 5; i++) {
//   let stars = "";
//   for (let j = 1; j <= i; j++) {
//     stars += "*";
//   }
//   console.log(stars);
// }


// // 5. Loop Control Statements:

// // Print numbers from 1 to 10, skipping 5:

// for (let i = 1; i <= 10; i++) {
//   if (i === 5) {
//     continue; 
//   }
//   console.log(i);
// }


// // Print numbers from 1 to 10, stopping at 7:

// for (let i = 1; i <= 10; i++) {
//   console.log(i);
//   if (i === 7) {
//     break; 
//   }
// }













// Day 5: Functions

// Tasks/Activities:

// Activity 1: Function Declaration

// • Task 1: Write a function to check if a number is even or odd and log the result to the console.
// function checkEvenOdd(number) {
//   if (number % 2 === 0) {
//       console.log(`${number} is even`);
//   } else {
//       console.log(`${number} is odd`);
//   }
// }

// // Example usage
// checkEvenOdd(4); // Output: 4 is even
// checkEvenOdd(7); // Output: 7 is odd

// // • Task 2: Write a function to calculate the square of a number and return the result.
// function square(number) {
//   return number * number;
// }

// // Example usage
// console.log(square(5)); // Output: 25
// console.log(square(9)); // Output: 81


// // Activity 2: Function Expression

// // Task 3: Write a function expression to find the maximum of two numbers and log the result to the console.
// const findMax = function(a, b) {
//   if (a > b) {
//       console.log(`Maximum is ${a}`);
//   } else {
//       console.log(`Maximum is ${b}`);
//   }
// }

// // Example usage
// findMax(10, 15); 
// findMax(23, 8);  
// // Task 4: Write a function expression to concatenate two strings and return the result.
// const concatenateStrings = function(str1, str2) {
//   return str1 + str2;
// }

// // Example usage
// console.log(concatenateStrings('Hello, ', 'World!')); 
// console.log(concatenateStrings('Foo', 'Bar')); 
// // Activity 3: Arrow Functions

// // Task 5: Write an arrow function to calculate the sum of two numbers and return the result.
// const sum = (a, b) => a + b;

// // Example usage
// console.log(sum(5, 10)); 
// console.log(sum(20, 30)); 

// // Task 6: Write an arrow function to check if a string contains a specific character and return a boolean value.
// const containsCharacter = (str, char) => str.includes(char);

// // Example usage
// console.log(containsCharacter('Hello', 'e')); 
// console.log(containsCharacter('World', 'a')); 
// // Activity 4: Function Parameters and Default Values

// // Task 7: Write a function that takes two parameters and returns their product. Provide a default value for the second parameter.
// function multiply(a, b = 1) {
//   return a * b;
// }

// // Example usage
// console.log(multiply(5, 3)); 
// console.log(multiply(7));    

// // Task 8: Write a function that takes a person's name and age and returns a greeting message. Provide a default value for the age.
// function greet(name, age = 18) {
//   return `Hello, ${name}! You are ${age} years old.`;
// }

// // Example usage
// console.log(greet('Alice', 25)); 
// console.log(greet('Bob'));       
// // Activity 5: Higher-Order Functions

// // Task 10: Write a higher-order function that takes two functions and a value, applies the first function to the value, and then applies the second function to the result.
// function applyFunctions(func1, func2, value) {
//   return func2(func1(value));
// }

// // Example usage
// const double = x => x * 2;
// const increment = x => x + 1;

// console.log(applyFunctions(double, increment, 5)); 

// // Task 9: Write a higher-order function that takes a function and a number, and calls the function that many times.
// function repeatFunction(func, times) {
//   for (let i = 0; i < times; i++) {
//       func();
//   }
// }

// // Example usage
// const sayHello = () => console.log('Hello!');

// repeatFunction(sayHello, 3); 


// Day 6: Arrays

// Tasks/Activities:

// Activity 1: Array Creation and Access

// // Task 1: Create an array of numbers from 1 to 5 and log the array to the console.
// let numbers = [1, 2, 3, 4, 5];
// console.log(numbers);

// // Task 2: Access the first and last elements of the array and log them to the console.
// let firstElement = numbers[0];
// let lastElement = numbers[numbers.length - 1];
// console.log(firstElement, lastElement);

// // Activity 2: Array Methods (Basic)

// // Task 3: Use the push method to add a new number to the end of the array and log the updated array.
// numbers.push(6);
// console.log(numbers);

// // Task 4: Use the pop method to remove the last element from the array and log the updated array.
// numbers.pop();
// console.log(numbers);

// // • Task 5: Use the shift method to remove the first element from the array and log the updated array.
// numbers.shift();
// console.log(numbers);

// // Task 6: Use the unshift method to add a new number to the beginning of the array and log the updated array.
// numbers.unshift(0);
// console.log(numbers);

// // Activity 3: Array Methods (Intermediate)

// // Task 7: Use the map method to create a new array where each number is doubled and log the new array.
// let doubledNumbers = numbers.map(num => num * 2);
// console.log(doubledNumbers);

// // Task 8: Use the filter method to create a new array with only even numbers and log the new array.
// let evenNumbers = numbers.filter(num => num % 2 === 0);
// console.log(evenNumbers);

// // Task 9: Use the reduce method to calculate the sum of all numbers in the array and log the result.
// let sum = numbers.reduce((acc, num) => acc + num, 0);
// console.log(sum);

// // Activity 4: Array Iteration

// // Task 10: Use a for loop to iterate over the array and log each element to the console.
// for (let i = 0; i < numbers.length; i++) {
//   console.log(numbers[i]);
// }

// // • Task 11: Use the forEach method to iterate over the array and log each element to the console.

// numbers.forEach(num => console.log(num));



// // Activity 5: Multi-dimensional Arrays

// // Task 12: Create a two-dimensional array (matrix) and log the entire array to the console.
// let matrix = [
//   [1, 2, 3],
//   [4, 5, 6],
//   [7, 8, 9]
// ];
// console.log(matrix);

// // Task 13: Access and log a specific element from the two-dimensional array.


// let specificElement = matrix[1][1]; // Accessing the element in the second row
             













// Day 7: Objects

// // Tasks/Activities:

// // Activity 1: Object Creation and Access

// // Task 1: Create an object representing a book with properties like title, author, and year, and log the object to the console.
// let book = {
//   title: "To Kill a Mockingbird",
//   author: "Harper Lee",
//   year: 1960
// };
// console.log(book); 
// // Output: { title: "To Kill a Mockingbird", author: "Harper Lee", year: 1960 }

// // Task 2: Access and log the title and author properties of the book object.
// console.log(book.title); // Output: "To Kill a Mockingbird"
// console.log(book.author); // Output: "Harper Lee"

// // Activity 2: Object Methods

// // Task 3: Add a method to the book object that returns a string with the book's title and author, and log the result of calling this method. 
// book.getDetails = function() {
//   return `${this.title} by ${this.author}`;
// };
// console.log(book.getDetails()); 
// // Output: "To Kill a Mockingbird by Harper Lee"

// // • Task 4: Add a method to the book object that takes a parameter (year) and updates the book's year property, then log the updated object.
// book.updateYear = function(newYear) {
//   this.year = newYear;
// };
// book.updateYear(2020);
// console.log(book); 
// // Output: { title: "To Kill a Mockingbird", author: "Harper Lee", year: 2020, getDetails: [Function], updateYear: [Function] }

// // Activity 3: Nested Objects

// // Task 5: Create a nested object representing a library with properties like name and books (an array of book objects), and log the library object to the console.
// let library = {
//   name: "City Library",
//   books: [
//     { title: "1984", author: "George Orwell", year: 1949 },
//     { title: "The Great Gatsby", author: "F. Scott Fitzgerald", year: 1925 },
//     book
//   ]
// };
// console.log(library); 
// // Output: { name: "City Library", books: [ { title: "1984", author: "George Orwell", year: 1949 }, { title: "The Great Gatsby", author: "F. Scott Fitzgerald", year: 1925 }, { title: "To Kill a Mockingbird", author: "Harper Lee", year: 2020, getDetails: [Function], updateYear: [Function] } ] }

// // Task 6: Access and log the name of the library and the titles of all the books in the library.
// console.log(library.name); // Output: "City Library"
// library.books.forEach(book => console.log(book.title));
// // Output: 
// // "1984"
// // "The Great Gatsby"
// // "To Kill a Mockingbird"

// // Activity 4: The this Keyword

// // Task 7: Add a method to the book object that uses the this keyword to return a string with the book's title and year, and log the result of calling this method.
// book.getTitleAndYear = function() {
//   return `${this.title} (${this.year})`;
// };
// console.log(book.getTitleAndYear()); 
// // Output: "To Kill a Mockingbird (2020)"

// // Activity 5: Object Iteration

// // Task 8: Use a for...in loop to iterate over the properties of the book object and log each property and its value.
// for (let key in book) {
//   if (book.hasOwnProperty(key)) {
//     console.log(`${key}: ${book[key]}`);
//   }
// }


// // Task 9: Use Object.keys and Object.values methods to log all the keys and values of the book object.
// console.log(Object.keys(book)); 
// // Output: ["title", "author", "year", "getDetails", "updateYear", "getTitleAndYear"]
// console.log(Object.values(book)); 
// // Output: ["To Kill a Mockingbird", "Harper Lee", 2020, function() { ... }, function() { ... }, function() { ... }]






// Day 8: ES6+ Features

// Tasks/Activities:

// Activity 1: Template Literals

// Task 1: Use template literals to create a string that includes variables for a person's name and age, and log the string to the console.
// const name = "John";
// const age = 30;
// const message = `My name is ${name} and I am ${age} years old.`;
// console.log(message);

// // Task 2: Create a multi-line string using template literals and l and log it to the console.
// const multiLineString = `This is a multi-line string.
// It spans multiple lines.
// And it's very easy to create using template literals.`;
// console.log(multiLineString);

// // Activity 2: Destructuring

// // Task 3: Use array destructuring to extract the first and second elements from an array of numbers and log them to the console.
// const numbers = [1, 2, 3, 4, 5];
// const [first, second] = numbers;
// console.log(first, second); // 1 2

// // • Task 4: Use object destructuring to extract the title and author from a book object and log them to the console.
// const book = {
//   title: "The Great Gatsby",
//   author: "F. Scott Fitzgerald",
//   year: 1925
// };
// const { title, author } = book;
// console.log(title, author); // The Great Gatsby F. Scott Fitzgerald

// // Activity 3: Spread and Rest Operators

// // Task 5: Use the spread operator to create a new array that includes all elements of an existing array plus additional elements, and log the newlyray to the console.
// const originalArray = [1, 2, 3];
// const newArray = [...originalArray, 4, 5, 6];
// console.log(newArray); // [1, 2, 3, 4, 5, 6]

// // Task 6: Use the rest operator in a function to accept an arbitrary number of arguments, sum them, and return the result.
// function sum(...args) {
//   return args.reduce((acc, curr) => acc + curr, 0);
// }
// console.log(sum(1, 2, 3, 4, 5)); // 15

// // Activity 4: Default Parameters

// // Task 7: Write a function that takes two parameters and returns their product, with the second parameter having a default value of 1. Log the result of calling this function with and without the second parameter.
// function multiply(a, b = 1) {
//   return a * b;
// }
// console.log(multiply(5, 2)); // 10
// console.log(multiply(5)); // 5

// // Activity 5: Enhanced Object Literals

// // Task 8: Use enhanced object literals to create an object with methods and properties, and log the object to the console. 
// const name1 = "Alice";
// const age2 = 25;
// const person = {
//   name1,
//   age2,
//   greet() {
//     console.log(`Hello, my name is ${this.name1} and I am ${this.age2} years old.`);
//   }
// };
// console.log(person);
// person.greet(); // Hello, my name is Alice and I am 25 years old.
// // Task 9: Create an object with computed property names based on variables and log the object to the console.
// const propName = "favoriteColor";
// const propValue = "blue";
// const obj = {
//   [propName]: propValue
// };
// console.log(obj); // { favoriteColor: "blue" }









// Day 9: DOM Manipulation

// Tasks/Activities:

// Activity 1: Selecting and Manipulating Elements

// Task 1: Select an HTML element by its ID and change its text content. 
// document.getElementById('myElement').textContent = 'New Text Content';
// // • Task 2: Select an HTML element by its class and change its background color.
// document.querySelector('.myClass').style.backgroundColor = 'blue';

// // Activity 2: Creating and Appending Elements

// // Task 3: Create a new div element with some text content and append it to the body.
// const newDiv = document.createElement('div');
// newDiv.textContent = 'This is a new div';
// document.body.appendChild(newDiv);

// // Task 4: Create a new 11 element and add it to an existing ul list.
// const newLi = document.createElement('li');
// newLi.textContent = 'New list item';
// document.querySelector('ul').appendChild(newLi);

// // Activity 3: Removing Elements

// // Task 5: Select an HTML element and remove it from the DOM.
// const elementToRemove = document.getElementById('elementToRemove');
// elementToRemove.parentNode.removeChild(elementToRemove);

// // Task 6: Remove the last child of a specific HTML element.
// const parentElement = document.getElementById('parentElement');
// parentElement.removeChild(parentElement.lastElementChild);

// // Activity 4: Modifying Attributes and Classes

// // Task 7: Select an HTML element and change one of its attributes (e.g., src of an ing tag).
// document.querySelector('img').setAttribute('src', 'newImageSource.jpg');

// // Task 8: Add and remove a CSS class to/from an HTML element.
// const element = document.querySelector('.myElement');
// element.classList.add('newClass');
// element.classList.remove('oldClass');

// // Activity 5: Event Handling

// // Task 9: Add a click event listener to a button that changes the text content of a paragraph.
// document.querySelector('button').addEventListener('click', () => {
//   document.querySelector('p').textContent = 'Text has been changed!';
// });

// // Task 10: Add a mouseover event listener to an element that changes its border color
// document.querySelector('.myElement').addEventListener('mouseover', () => {
//   document.querySelector('.myElement').style.borderColor = 'red';
// });






// // ### Tasks/Activities:

// // #### Activity 1: Basic Event Handling
// // - *Task 1*: Add a click event listener to a button that changes the text content of a paragraph.
// addEventListener('click', () => {
//   document.querySelector('p').textContent = 'Text has been changed!';
// })
// // - *Task 2*: Add a double-click event listener to an image that toggles its visibility.
// addEventListener('dblclick', () => {
//   document.querySelector('img').style.opacity = '0';
// })

// // #### Activity 2: Mouse Events
// // - *Task 3*: Add a mouseover event listener to an element that changes its background color.
// addEventListener('mouseover', () => {
//   document.querySelector('.myElement').style.backgroundColor = 'red';
// })
// // - *Task 4*: Add a mouseout event listener to an element that resets its background color.
// addEventListener('mouseout', () => {
//   document.querySelector('.myElement').style.backgroundColor = 'white';
// })

// // #### Activity 3: Keyboard Events
// // - *Task 5*: Add a keydown event listener to an input field that logs the key pressed to the console.
// addEventListener('keydown', (event) => {
//   console.log(event.key);
// })
// // - *Task 6*: Add a keyup event listener to an input field that displays the current value in a paragraph.
// addEventListener('keyup', (event) => {
//   document.querySelector('p').textContent = event.target.value;
// })

// // #### Activity 4: Form Events
// // - *Task 7*: Add a submit event listener to a form that prevents the default submission and logs the form data to the console.
// addEventListener('submit', (event) => {
//   event.preventDefault();
// })
// // - *Task 8*: Add a change event listener to a select dropdown that displays the selected value in a paragraph.
// addEventListener('change', (event) => {
//   document.querySelector('p').textContent = event.target.value;
// })
// // #### Activity 5: Event Delegation
// // - *Task 9*: Add a click event listener to a list that logs the text content of the clicked list item using event delegation.
// addEventListener('click', (event) => {
//   console.log(event.target.textContent);
// })
// // - *Task 10*: Add an event listener to a parent element that listens for events from dynamically added child elements.
// addEventListener('click', (event) => {
//   console.log(event.target.textContent);
// })





// // Day 11: Promises and Async/Await

// // Tasks/Activities:

// // Activity 1: Understanding Promises

// // Task 1: Create a promise that resolves with a message after a 2-second timeout and log the message to the console.
// const promise1 = new Promise((resolve) => {
//     setTimeout(() => {
//       resolve("Promise resolved after 2 seconds");
//     }, 2000);
//   });
  
//   promise1.then((message) => {
//     console.log(message);
//   });
  
// // Task 2: Create a promise that rejects with an error message after a 2-second timeout and handle the error using catch().
// const promise2 = new Promise((_, reject) => {
//     setTimeout(() => {
//       reject("Promise rejected after 2 seconds");
//     }, 2000);
//   });
  
//   promise2.catch((error) => {
//     console.error(error);
//   });
  
// // Activity 2: Chaining Promises

// // Task 3: Create a sequence of promises that simulate fetching data from a server. Chain the promises to log messages in a specific order.
// const fetchData = (data) => {
//     return new Promise((resolve) => {
//       setTimeout(() => {
//         resolve(data);
//       }, 1000);
//     });
//   };
  
//   fetchData("Fetching user data")
//     .then((message) => {
//       console.log(message);
//       return fetchData("Fetching posts data");
//     })
//     .then((message) => {
//       console.log(message);
//       return fetchData("Fetching comments data");
//     })
//     .then((message) => {
//       console.log(message);
//     });
  
// // Activity 3: Using Async/Await

// // Task 4: Write an async function that waits for a promise to resolve and then logs the resolved value.
// const asyncFunction = async () => {
//     const promise = new Promise((resolve) => {
//       setTimeout(() => {
//         resolve("Resolved value");
//       }, 2000);
//     });
  
//     const result = await promise;
//     console.log(result);
//   };
  
//   asyncFunction();
  
// // Task 5: Write an async function that handles a rejected promise using try-catch and logs the error message.
// const asyncFunctionWithError = async () => {
//     const promise = new Promise((_, reject) => {
//       setTimeout(() => {
//         reject("Error occurred");
//       }, 2000);
//     });
  
//     try {
//       const result = await promise;
//       console.log(result);
//     } catch (error) {
//       console.error(error);
//     }
//   };
  
//   asyncFunctionWithError();
  
// // Activity 4: Fetching Data from an A

// // Task 6: Use the fetch API to get data from a public API and log the response data to the console using promises.
// fetch('https://api.publicapis.org/entries')
//   .then(response => response.json())
//   .then(data => {
//     console.log(data);
//   })
//   .catch(error => {
//     console.error('Error fetching data:', error);
//   });

// // • Task 7: Use the fetch API to get data from a public API and log the response data to the console using async/await.
// const fetchDataAsync = async () => {
//     try {
//       const response = await fetch('https://api.publicapis.org/entries');
//       const data = await response.json();
//       console.log(data);
//     } catch (error) {
//       console.error('Error fetching data:', error);
//     }
//   };
  
//   fetchDataAsync();
  
// // Activity 5: Concurrent Promises

// // Task 8: Use Promise.all to wait for multiple promises to resolve and then log all their values.
// const promiseA = new Promise((resolve) => setTimeout(resolve, 1000, "Promise A"));
// const promiseB = new Promise((resolve) => setTimeout(resolve, 2000, "Promise B"));
// const promiseC = new Promise((resolve) => setTimeout(resolve, 3000, "Promise C"));

// Promise.all([promiseA, promiseB, promiseC]).then((values) => {
//   console.log(values); // ["Promise A", "Promise B", "Promise C"]
// });

// // Task 9: Use Promise.race to log the value of the first promise that resolves among multiple promises.
// const promiseX = new Promise((resolve) => setTimeout(resolve, 1000, "Promise X"));
// const promiseY = new Promise((resolve) => setTimeout(resolve, 2000, "Promise Y"));
// const promiseZ = new Promise((resolve) => setTimeout(resolve, 3000, "Promise Z"));

// Promise.race([promiseX, promiseY, promiseZ]).then((value) => {
//   console.log(value); // "Promise X"
// });




// Day 12: Error Handlin

// Tasks/Activities:

// Activity 1: Basic Error Handling with Try-Catch

// Task 1: Write a function that intentionally throws an error and use a try-catch block to handle the error and log an appropriate message to the console.
// function throwError() {
//   throw new Error('Intentional Error');
// }

// try {
//   throwError();
// } catch (error) {
//   console.error('Caught an error:', error.message);
// }

// // Task 2: Create a function that divides two numbers and throws an error if the denominator is zero. Use a try-catch block to handle this error.
// function divide(a, b) {
//   if (b === 0) {
//       throw new Error('Cannot divide by zero');
//   }
//   return a / b;
// }

// try {
//   console.log(divide(10, 0));
// } catch (error) {
//   console.error('Error:', error.message);
// }

// // Activity 2: Finally Block

// // Task 3: Write a script that includes a try-qatch block and a finally block. Log messages in the try, catch, and finally blocks to observe the execution flow.
// try {
//   console.log('In try block');
//   throw new Error('Error in try block');
// } catch (error) {
//   console.error('In catch block:', error.message);
// } finally {
//   console.log('In finally block');
// }

// // Activity 3: Custom Error Objects

// // Task 4: Create a custom error class that extends the built-in Error class. Throw an instance of this custom error in a function and handle it using a try catch block.
// class CustomError extends Error {
//   constructor(message) {
//       super(message);
//       this.name = 'CustomError';
//   }
// }

// function throwCustomError() {
//   throw new CustomError('This is a custom error');
// }

// try {
//   throwCustomError();
// } catch (error) {
//   console.error(`${error.name}: ${error.message}`);
// }

// // Task 5: Write a function that validates user input (e.g., checking if a string is not empty) and throws a custom error if the validation fails. Handle the custom error using a try-catch block.
// class ValidationError extends Error {
//   constructor(message) {
//       super(message);
//       this.name = 'ValidationError';
//   }
// }

// function validateInput(input) {
//   if (input.trim() === '') {
//       throw new ValidationError('Input cannot be empty');
//   }
//   return true;
// }

// try {
//   validateInput('');
// } catch (error) {
//   console.error(`${error.name}: ${error.message}`);
// }

// // Activity 4: Error Handling in Promises

// const randomPromise = new Promise((resolve, reject) => {
//   const randomNumber = Math.random();
//   if (randomNumber > 0.5) {
//     resolve('Promise resolved');
//   } else {
//     reject(new Error('Promise rejected'));
//   }
// });

// randomPromise
// .then((message) => {
//   console.log(message);
// })
// .catch((error) => {
//   console.error('Error:', error.message);
// });
// // Task 6: Create a promise that randomly resolves or rejects. Use .catch() to handle the rejection and log an appropriate message to the console. Task 7: Use try-catch within an async function to handle errors from a promise that randomly resolves or rejects, and log the error message.

//   async function handleRandomPromise() {
//     const randomPromise = new Promise((resolve, reject) => {
//         const randomNumber = Math.random();
//         if (randomNumber > 0.5) {
//             resolve('Promise resolved');
//         } else {
//             reject(new Error('Promise rejected'));
//         }
//     });
  
//     try {
//         const result = await randomPromise;
//         console.log(result);
//     } catch (error) {
//         console.error('Caught an error:', error.message);
//     }
//   }
  
//   handleRandomPromise();
// // Activity 5: Graceful Error Handling in Fetch

// // • Task 8: Use the fetch API to request data from an invalid URL and handle the error using .catch(). Log an appropriate error message to the console.
// fetch('https://invalidurl.example')
//     .then((response) => response.json())
//     .catch((error) => {
//         console.error('Fetch error:', error.message);
//     });

// // Task 9: Use the fetch API to request data from an invalid URL within an async function and handle the error using try-catch. Log an appropriate error message.
// async function fetchInvalidURL() {
//   try {
//       const response = await fetch('https://invalidurl.example');
//       const data = await response.json();
//       console.log(data);
//   } catch (error) {
//       console.error('Fetch error:', error.message);
//   }
// }

// fetchInvalidURL();













// Day 15: Closures

// Tasks/Activities:

// Activity 1: Understanding Closures

// Task 1: Write a function that returns another function, where the inner function accesses a variable from the outer function's scope. Call the inner function and log the result.
// f


// Day 16: Recursion

// Tasks/Activities:

// Activity 1: Basic Recursion

// Task 1: Write a recursive function to calculate the factorial of a number. Log the result for a few test cases.
// function factorial(n) {
//   if (n === 0) {
//       return 1;
//   }
//   return n * factorial(n - 1);
// }

// // Test cases
// console.log(factorial(5));  // Output: 120
// console.log(factorial(0));  // Output: 1
// console.log(factorial(7));  // Output: 5040

// // Task 2: Write a recursive function to calculate the nth Fibonacci number. Log the result for a few test cases.
// function fibonacci(n) {
//   if (n <= 1) {
//       return n;
//   }
//   return fibonacci(n - 1) + fibonacci(n - 2);
// }

// // Test cases
// console.log(fibonacci(5));  // Output: 5
// console.log(fibonacci(10)); // Output: 55
// console.log(fibonacci(0));  // Output: 0

// // Activity 2: Recursion with Arrays

// // • Task 3: Write a recursive function to find the sum of all elements in an array. Log the result for a few test cases.
// function sumArray(arr) {
//   if (arr.length === 0) {
//       return 0;
//   }
//   return arr[0] + sumArray(arr.slice(1));
// }

// // Test cases
// console.log(sumArray([1, 2, 3, 4, 5])); // Output: 15
// console.log(sumArray([10, 20, 30]));    // Output: 60
// console.log(sumArray([]));              // Output: 0

// // Task 4: Write a recursive function to find the maximum element in an array. Log the result for a few test cases.
// function maxArray(arr) {
//   if (arr.length === 1) {
//       return arr[0];
//   }
//   return Math.max(arr[0], maxArray(arr.slice(1)));
// }

// // Test cases
// console.log(maxArray([1, 2, 3, 4, 5])); // Output: 5
// console.log(maxArray([10, 20, 5, 7]));  // Output: 20
// console.log(maxArray([-10, -20, -5]));  // Output: -5

// // Activity 3: String Manipulation with Recursion

// // Task 5: Write a recursive function to reverse a string. Log the result for a few test cases.
// function reverseString(str) {
//   if (str === "") {
//       return "";
//   }
//   return reverseString(str.slice(1)) + str[0];
// }

// // Test cases
// console.log(reverseString("hello"));  // Output: "olleh"
// console.log(reverseString("world"));  // Output: "dlrow"
// console.log(reverseString(""));       // Output: ""

// // Task 6: Write a recursive function to check if a string is a palindrome. Log the result for a few test cases.
// function isPalindrome(str) {
//   if (str.length <= 1) {
//       return true;
//   }
//   if (str[0] !== str[str.length - 1]) {
//       return false;
//   }
//   return isPalindrome(str.slice(1, -1));
// }

// // Test cases
// console.log(isPalindrome("racecar")); // Output: true
// console.log(isPalindrome("hello"));   // Output: false
// console.log(isPalindrome("madam"));   // Output: true

// // Activity 4: Recursive Search

// // Task 7: Write a recursive function to perform a binary search on a sorted array. Log the index of the target element for a few test cases.
// function binarySearch(arr, target, left = 0, right = arr.length - 1) {
//   if (left > right) {
//       return -1;
//   }
//   const mid = Math.floor((left + right) / 2);
//   if (arr[mid] === target) {
//       return mid;
//   }
//   if (arr[mid] > target) {
//       return binarySearch(arr, target, left, mid - 1);
//   }
//   return binarySearch(arr, target, mid + 1, right);
// }

// // Test cases
// console.log(binarySearch([1, 2, 3, 4, 5], 3));  // Output: 2
// console.log(binarySearch([1, 2, 3, 4, 5], 6));  // Output: -1
// console.log(binarySearch([10, 20, 30, 40, 50], 40)); // Output: 3

// // Task 8: Write a recursive function to count the occurrences of a target element in an array. Log the result for a few test cases.
// function countOccurrences(arr, target) {
//   if (arr.length === 0) {
//       return 0;
//   }
//   return (arr[0] === target ? 1 : 0) + countOccurrences(arr.slice(1), target);
// }

// // Test cases
// console.log(countOccurrences([1, 2, 3, 2, 2, 4, 5], 2)); // Output: 3
// console.log(countOccurrences([1, 1, 1, 1, 1], 1));       // Output: 5
// console.log(countOccurrences([1, 2, 3, 4, 5], 6));       // Output: 0

// // Activity 5: Tree Traversal (Optional)

// // Task 9: Write a recursive function to perform an in-order traversal of a binary tree. Log the nodes as they are visited.
// class TreeNode {
//   constructor(value) {
//       this.value = value;
//       this.left = null;
//       this.right = null;
//   }
// }

// function inOrderTraversal(node) {
//   if (node === null) {
//       return;
//   }
//   inOrderTraversal(node.left);
//   console.log(node.value);
//   inOrderTraversal(node.right);
// }

// // Test case
// let root = new TreeNode(1);
// root.left = new TreeNode(2);
// root.right = new TreeNode(3);
// root.left.left = new TreeNode(4);
// root.left.right = new TreeNode(5);

// inOrderTraversal(root); // Output: 4, 2, 5, 1, 3

// // Task 10: Write a recursive function to calculate the depth of a binary tree. Log the result for a few test cases.
// function treeDepth(node) {
//   if (node === null) {
//       return 0;
//   }
//   return 1 + Math.max(treeDepth(node.left), treeDepth(node.right));
// }

// // Test cases
// let root = new TreeNode(1);
// root.left = new TreeNode(2);
// root.right = new TreeNode(3);
// root.left.left = new TreeNode(4);
// root.left.right = new TreeNode(5);

// console.log(treeDepth(root)); // Output: 3



// Day 17: Data Structures

// Tasks/Activities:

// Activity 1: Linked List

// Task 1: Implement a Node class to represent an element in a linked list with properties value and next.
class Node {
  constructor(value) {
      this.value = value;
      this.next = null;
  }
}

// • Task 2: Implement a LinkedList class with methods to add a node to the end, remove a node from the end, and display all nodes.
class LinkedList {
  constructor() {
      this.head = null;
  }

  add(value) {
      const newNode = new Node(value);
      if (!this.head) {
          this.head = newNode;
      } else {
          let current = this.head;
          while (current.next) {
              current = current.next;
          }
          current.next = newNode;
      }
  }

  remove() {
      if (!this.head) return null;

      if (!this.head.next) {
          const removedValue = this.head.value;
          this.head = null;
          return removedValue;
      }

      let current = this.head;
      while (current.next.next) {
          current = current.next;
      }
      const removedValue = current.next.value;
      current.next = null;
      return removedValue;
  }

  display() {
      if (!this.head) return [];

      const values = [];
      let current = this.head;
      while (current) {
          values.push(current.value);
          current = current.next;
      }
      return values;
  }
}

// Activity 2: Stack

// Task 3: Implement a Stack class with methods push (add element), pop (remove element), and peek (view the top element).
class Stack {
  constructor() {
      this.items = [];
  }

  push(element) {
      this.items.push(element);
  }

  pop() {
      if (this.items.length === 0) return null;
      return this.items.pop();
  }

  peek() {
      if (this.items.length === 0) return null;
      return this.items[this.items.length - 1];
  }
}

// • Task 4: Use the Stack class to reverse a string by pushing all characters onto the stack and then popping them off.
function reverseString(str) {
  const stack = new Stack();
  for (let char of str) {
      stack.push(char);
  }
  let reversedStr = '';
  while (stack.peek() !== null) {
      reversedStr += stack.pop();
  }
  return reversedStr;
}

// Activity 3: Queue

// Task 5: Implement a Queue class with methods enqueue (add element), dequeue (remove element), and front (view the first element).
class Queue {
  constructor() {
      this.items = [];
  }

  enqueue(element) {
      this.items.push(element);
  }

  dequeue() {
      if (this.items.length === 0) return null;
      return this.items.shift();
  }

  front() {
      if (this.items.length === 0) return null;
      return this.items[0];
  }
}

// • Task 6: Use the Queue class to simulate a simple printer queue where print jobs are added to the queue and processed in order.
class PrinterQueue {
  constructor() {
      this.queue = new Queue();
  }

  addPrintJob(job) {
      this.queue.enqueue(job);
  }

  processPrintJob() {
      if (this.queue.front() === null) {
          console.log('No print jobs in the queue.');
      } else {
          const job = this.queue.dequeue();
          console.log(`Processing print job: ${job}`);
      }
  }
}

// Activity 4: Binary Tree

// Task 7: Implement a TreeNode class to represent a node in a binary tree with properties value, left, and right.
class TreeNode {
  constructor(value) {
      this.value = value;
      this.left = null;
      this.right = null;
  }
}

// Task 8: Implement a BinaryTree class with methods for inserting values and performing in-order traversal to display nodes.
class BinaryTree {
  constructor() {
      this.root = null;
  }

  insert(value) {
      const newNode = new TreeNode(value);
      if (!this.root) {
          this.root = newNode;
          return;
      }

      let current = this.root;
      while (true) {
          if (value < current.value) {
              if (!current.left) {
                  current.left = newNode;
                  break;
              }
              current = current.left;
          } else {
              if (!current.right) {
                  current.right = newNode;
                  break;
              }
              current = current.right;
          }
      }
  }

  inOrderTraversal(node = this.root, result = []) {
      if (node) {
          this.inOrderTraversal(node.left, result);
          result.push(node.value);
          this.inOrderTraversal(node.right, result);
      }
      return result;
  }
}

// Activity 5: Graph (Optional)

// Task 9: Implement a Graph class with methods to add vertices, add edges, and perform a breadth-first search (BFS).
class Graph {
  constructor() {
      this.vertices = {};
  }

  addVertex(vertex) {
      if (!this.vertices[vertex]) {
          this.vertices[vertex] = [];
      }
  }

  addEdge(vertex1, vertex2) {
      if (this.vertices[vertex1] && this.vertices[vertex2]) {
          this.vertices[vertex1].push(vertex2);
          this.vertices[vertex2].push(vertex1);
      }
  }

  bfs(start) {
      if (!this.vertices[start]) return null;

      const queue = [start];
      const visited = { [start]: true };
      const result = [];

      while (queue.length) {
          const vertex = queue.shift();
          result.push(vertex);

          this.vertices[vertex].forEach(neighbor => {
              if (!visited[neighbor]) {
                  visited[neighbor] = true;
                  queue.push(neighbor);
              }
          });
      }
      return result;
  }
}

// Task 10: Use the Graph class to represent a simple network and perform BFS to find the shortest path between two nodes.
const graph = new Graph();
graph.addVertex('A');
graph.addVertex('B');
graph.addVertex('C');
graph.addVertex('D');
graph.addEdge('A', 'B');
graph.addEdge('A', 'C');
graph.addEdge('B', 'D');
graph.addEdge('C', 'D');

const shortestPath = graph.bfs('A');
console.log(shortestPath); // Output: ['A', 'B', 'C', 'D']
